# Отчёт по лабораторной работе №3

- Выполнил: Абульфатов Руслан
- Группа: P33312
- Вариант: `alg | acc | harv | mc | tick | struct | stream | port | cstr | prob2 | [4]char`

## Язык программирования

По варианту необходимо реализовать Java/JavaScript/Lua-подобный язык.

Был реализован JavaScript-подобный язык с различными упрощениями.

Реализована поддержка:
* создание переменных
* числовые и строковые литералы
* математические выражения с приоритетами и группировкой `()`
* ветвление `if`
* цикл `while`
* посимвольный ввод/вывод

Грамматика языка:

```ebnf
letter ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | 
       "h" | "i" | "j" | "k" | "l" | "m" | "n" | 
       "o" | "p" | "q" | "r" | "s" | "t" | "u" | 
       "v" | "w" | "x" | "y" | "z" 

digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

variable_name ::= letter (letter | digit)*

number ::= digit+

string ::= "\"" <any symbol except a double quote>  "\""

string_access ::= variable_name "[" expression "]"        

operator ::= 
    "+" | "-" | "*" | "/" | "%" | 
    "==" | "!=" | "<" | ">" | "<=" | ">=" 
    
expression ::= 
    number |
    variable_name |
    string_access |
    expression operator expression |
    "(" expression ")" |
    "input" "(" ")" 

statement ::= 
    "var" variable_name |
    "if" "(" expression ")" "{" statement* "}" |
    "while" "(" expression ")" "{" statement* "}" |
    variable_name "=" expression |
    variable_name "=" string | 
    string_access "=" expression |
    "print" "(" experession ")"

program ::= statement*
```

Вычисления производятся последовательно, за исключением ветвления и циклов. 

Область видимости всех переменных - глобальная, потому что нет поддержки функций и процедур.

Язык поддерживает два типа данных:

* 32-битное знаковое целое число
* строка (C-string)

Булевые литералы не поддерживаются для упрощения языка, но операции сравнения (`==`, `!=`, `<` и т. д.) возвращают `1` или `0` -- в зависимости от результата сравнения. Операции сравнения не являются частью конструкций `if` и `while`, и могут использоваться в любом контексте.

`print` и `input` осуществляют ввод/вывод посимвольно. Один символ выводится или вводится за один вызов.

Комментарии не поддерживаются для упрощения транслятора.

## Организация памяти

Используется гарвардская модель памяти с разделением на память инструкций и память данных.

Память инструкций: машинное слово -- не определено. Реализуется списком словарей, описывающих инструкции (одно слово -- одна ячейка).

Память данных: машинное слово -- 32-битное целое, знаковое. Линейное адресное пространство. Реализуется списком чисел.

Числовые константы не выделяются в памяти данных, потому что они являются частью инструкций загрузки, сложения и т. д. Например, `LD 5` загружает число `5` в `ACC`, при этом само число является частью инструкции. 

Также транслятор может создавать временные числовые переменные при трансляции выражений для сохранения промежуточных результатов, например, при разборе составных математических выражений со скобками. Обращение к данным временным переменным происходит при помощи непосредственой адресации. Временные переменные также выделяются в памяти данных последовательно, по мере необходимости.

Строки сохраняются в памяти данных последовательно по мере обнаружения их в программе транслятором. Один символ - одна ячейка. Когда строковые переменные встречаются в программе, транслятор использует их адрес в памяти данных.

Программисту доступен один регистр `ACC` (аккумулятор), все вычисления производятся с его участием. Так как регистр всего один, то никакие переменные не отображаются на него.

## Система команд

Особенности процессора:

* Аккумуляторная архитектура
* 32-битное машинное слово
* Доступ к памяти инструкций осуществляется по адресу, хранимому в специальном регистре `PC`.
* Доступ к памяти микро-инструкций осуществляется по адресу, хранимому в специальном регистре `mPC`.
* Доступ к памяти данных осуществляется по адресу, хранимому в специальном регистре `data_address`.
* Поток управления: 
 * инкремент mPC после каждой микро-инструкции;
 * инкремент PC после каждой инструкции;
 * условные (je, jne, jg, jl, jge, jle) и безусловный (jmp) переходы

### Набор инструкций 

| Инструкция  | Тип аргумента    | Кол-во тактов  | Пояснение                                          |
|:------------|------------------|:---------------|:---------------------------------------------------|
| LD          | immediate        | ???            | Загрузка числа в ACC
| LD          | address          | ???            | Прямая адресация
| LD          | indirect_address | ???            | Косвенная адресация
| ST          | address          | ???            | Сохранение ACC по адресу
| ST          | indirect_address | ???            | Косвенная адресация
| ADD         | immediate        | ???            | Прибавить число к ACC
| ADD         | address          | ???            | Прямая адресация
| SUB         | immediate        | ???            | Прибавить число к ACC
| SUB         | address          | ???            | Прямая адресация
| MUL         | immediate        | ???            | Прибавить число к ACC
| MUL         | address          | ???            | Прямая адресация
| DIV         | immediate        | ???            | Прибавить число к ACC
| DIV         | address          | ???            | Прямая адресация
| MOD         | immediate        | ???            | Прибавить число к ACC
| MOD         | address          | ???            | Прямая адресация
| JMP         | address          | ???            | Безусловный переход
| JE          | address          | ???            | Переход при равенстве
| JNE         | address          | ???            | Переход при неравенстве
| JG          | address          | ???            | Переход, если больше
| JL          | address          | ???            | Переход, если меньше
| JGE         | address          | ???            | Переход, если больше или равно
| JLE         | address          | ???            | Переход, если меньше или равно
| HLT         | (нет аргумента)  | 2              | Останов


### Способ кодирования инструкций

* Машинный код сериализуется в список JSON.
* Один элемент списка -- одна инструкция.
* Индекс списка -- адрес инструкции. Используется для команд перехода.

```json
{
    'opcode': 'add',
    'arg_type': 'address',
    'arg': 5
}
```
где:
* opcode -- строка с кодом операции;
* arg_type -- тип аргумента (например, `immediate`, `address`)
* arg -- аргумент (отсутствует у инструкции `HLT`);

## Транслятор

Интерфейс командной строки: 

```
translator.py <input_file> <output_code> <output_data>
```

где
* `input_file` - имя файла с программой на языке программирования
* `output_code` - имя файла для записи списка инструкций в формате JSON
* `output_data` - имя файла для записи памяти данных в формате JSON

Этапы трансляции:

1. Трансформирование текста в последовательность значимых токенов.
2. Парсинг токенов с одновременной генерацией машинного кода.

Правила генерации машинного кода:

* Один токен языка -- одна или несколько инструкций;
* Код для математических выражений генерируется слева направо, все вычисления происходят на аккумуляторе. При необходимости автоматически создаются временные переменные, если вычисление выражения невозможно произвести используя только аккумулятор
* Простые присвоения порождают инструкцию `ST` с предварительным вычислением правой части от знака присвоения `=`. (Пример инструкции: `x = 5`) 
* Присвоения к элементы строки порождают инструкцию `ST` с предварительным вычислением адреса символа на основе индекса и с вычислением правой части от знака присвоения `=` (Пример инструкции: `s[i] = 97`) 
* Для ветвления `if` генерируются инструкция перехода `JE` (прыжок через тело конструкции):

| Номер инструкции | Программа       | Машинный код         |
| ---------------- | --------------- | -------------------- |
| n                | if (условие)    | (вычисление условия) |
| n + 1            |                 | je k                 |
| ...              | ...             | (тело цикла)         |
| k                | ...             | ...                  |

Перед генерацией `CMP` генерируется код, вычисляющий значение уловия `if`.
* Для цикла `while` генерируются инструкция перехода `JE` (прыжок через тело конструкции):

| Номер инструкции | Программа       | Машинный код         |
| ---------------- | --------------- | -------------------- |
| n                | while (условие) | (вычисление условия) |
| n + 1            |                 | je k + 1             |
| ...              | ...             | (тело цикла)         |
| k                | }               | jmp n                |
| k + 1            | ...             | ...                  |

Перед генерацией `JE` генерируется код, вычисляющий значение условия `while`.
* Ключевое слово `print` генерирует инструкцию вывода в порт -- `OUT`
* Ключевое слово `input` генерирует инструкцию ввода из порта -- `IN`


## Модель процессора

Интерфейс командной строки: 

```
machine.py <input_code> <input_data> <input_file>
```

где
* `input_code` - имя файла с программой на языке программирования
* `input_data` - имя файла с описанием памяти данных в формате JSON
* `input_file` - имя файла с входным буффером для симулятора

Проргамма выводит журнал работы симулятора и выход данных процессора на экран.

### Data Path

************************* СХЕМА DATA PATH *************************
************************* СХЕМА DATA PATH *************************
************************* СХЕМА DATA PATH *************************

Реализован в классе DataPath.

`data_memory` -- однопортовая память, поэтому либо читаем, либо пишем.

Сигналы (обрабатываются за один такт):

* `latch_data_address` -- защёлкнуть выбранное значение в регистр `data_address`:
    * выход из модуля памяти (`data_out`)
    * операнд инструкции (`instruction_arg`)
* `data_read` -- перевод памяти в режим чтения
* `data_write` -- записать аккумулятор в память
* `latch_acc` -- защёлкнуть в аккумулятор выбранное значение:
    * операнд инструкции (`instruction_arg`)
    * значение из входного буфера (обработка на Python):
        * извлечь из входного буфера значение и записать в память
        * если буфер пуст -- выбросить исключение
    * выход из модуля памяти (`data_out`)
    * результат вычислений на АЛУ
* `output_write` -- записать аккумулятор в порт вывода (обработка на Python).
* АЛУ выполняет операцию, заданную `alu_operation_sel`:
    * левый операнд -- всегда аккумулятор
    * правый операнд выбирается на основании сигнала `alu_operand_sel`:
        * выход из модуля памяти (`data_out`)
        * операнд инструкции (`instruction_arg`)

Флаги:

* `negative_flag` -- отражает наличие отрицательного значения в аккумуляторе.
* `zero_flag` -- отражает наличие нулевого значения в аккумуляторе.
* `positive_flag` -- отражает наличие положительного значения в аккумуляторе.



### Control Unit

************************* CONTROL UNIT *************************
************************* CONTROL UNIT *************************
************************* CONTROL UNIT *************************

Реализован в классе ControlUnit.

`code_memory` -- однопортовая память, поэтому либо читаем, либо пишем. Всегда находится в режиме чтения.

`micro_code_memory` -- однопортовая память, поэтому либо читаем, либо пишем. Всегда находится в режиме чтения.

Сигналы:
* `latch_pc` - записать в регистр `PC` выбранное значение:
    * аргумент инструкции перехода (`JMP`, `JE`, `JG` и т.д.)
    * адрес следующей инструкции
* `mpc_sel` - записать в регистр `mPC` выбранное значение:
    * ноль - выбор специальной микро-инструкции для загрузки нового микрокода (выбирается при переходе к новой инструкции)
    * адрес, приходящий с декодера инструкции (используется, когда новая инструкция уже выбрана в памяти инструкций)
    * адрес следующей микро-инструкции
* `jump_if_negative`, `jump_if_zero`, `jump_if_positive` - активные, если необходимо сделать условный или безусловный прыжок (данные сигналы сигналы показывают условие перехода)


## Тестирование

В качестве тестов использовано три алгоритма:

1. hello world -- программа, выводящая "hello world"
2. cat -- программа cat, повторяем ввод на выводе.
3. hello user name -- программа, приветствующая пользователя
4. prob2 -- подсчёт чётных чисел Фибоннаячи до 4000000




